import{_ as i,c as a,o as n,a8 as e}from"./chunks/framework.Cc4yYURl.js";const o=JSON.parse('{"title":"web 应用榨干 CPU 性能的正确姿势","description":"","frontmatter":{"createDate":"2021/09/03","title":"web 应用榨干 CPU 性能的正确姿势"},"headers":[],"relativePath":"技术的小记/web 应用榨干 CPU 性能的正确姿势/index.md","filePath":"技术的小记/web 应用榨干 CPU 性能的正确姿势/index.md","lastUpdated":1755795391000}'),l={name:"技术的小记/web 应用榨干 CPU 性能的正确姿势/index.md"};function p(h,s,k,r,t,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="web-应用榨干-cpu-性能的正确姿势" tabindex="-1">web 应用榨干 CPU  性能的正确姿势 <a class="header-anchor" href="#web-应用榨干-cpu-性能的正确姿势" aria-label="Permalink to &quot;web 应用榨干 CPU  性能的正确姿势&quot;">​</a></h1><p><strong>2021/09/03</strong></p><nav class="table-of-contents"><ul><li><a href="#浏览器的线程分配">浏览器的线程分配</a></li><li><a href="#javascript-单线程的优劣">JavaScript 单线程的优劣</a></li><li><a href="#worker-和-多线程">Worker 和 多线程</a></li><li><a href="#web-workers-api">Web Workers API</a></li><li><a href="#多线程编程实践">多线程编程实践</a><ul><li><a href="#最佳线程数">最佳线程数</a></li><li><a href="#线程池">线程池</a></li><li><a href="#worker-嵌套">Worker 嵌套</a></li></ul></li><li><a href="#多线程性能对比">多线程性能对比</a></li><li><a href="#限制">限制</a><ul><li><a href="#脚本同源限制">脚本同源限制</a></li><li><a href="#工程化问题">工程化问题</a></li><li><a href="#api-访问限制">api 访问限制</a></li></ul></li></ul></nav><h2 id="浏览器的线程分配" tabindex="-1">浏览器的线程分配 <a class="header-anchor" href="#浏览器的线程分配" aria-label="Permalink to &quot;浏览器的线程分配&quot;">​</a></h2><p>现代浏览器普遍采用多进程架构，将网络 I/O、存储、插件等功能分开不同的进程进行处理，其中最重要的，为每一个新开的 tab 都创建了独立的进程。这样做的好处显而易见：某个页面卡死不会导致整个浏览器卡死，也不会影响其他页面（也有例外，当计算机资源不足以新开进程时，浏览器会合并一些 tab 到同一个进程中）。一个 web 应用运行在一个 tab 进程中，即 渲染进程（Renderer Process）。这个进程负责整个网页运行的多种事务。一般地，会维护以下几个线程：</p><ol><li>GUI 渲染线程</li><li>JavaScript 线程</li><li>定时触发器线程</li><li>事件触发线程</li><li>http 异步请求线程</li></ol><p>其中，GUI 线程和 JavaScript 线程是互斥的，当 GUI 渲染开始时，JavaScript 停止解析；反过来当 JavaScript 执行时，GUI 挂起。</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3psq8x3j384qxosrchx9.png" alt="浏览器线程"> 图片来自 <a href="https://developer.chrome.com/blog/inside-browser-part1" target="_blank" rel="noreferrer">Inside look at modern web browser (part 1)</a></p><h2 id="javascript-单线程的优劣" tabindex="-1">JavaScript 单线程的优劣 <a class="header-anchor" href="#javascript-单线程的优劣" aria-label="Permalink to &quot;JavaScript 单线程的优劣&quot;">​</a></h2><p>JavaScript 被设计成单线程执行，那么浏览器便不需要考虑 DOM 等资源同时被多个线程操作带来的竞争问题，降低了设计的复杂度。</p><p>那么，古尔丹，代价是什么呢？JavaScript 线程和 GUI 线程互斥，当 JavaScript 线程执行稍微耗时一点的计算时，UI 被阻断，应用卡死。还有一个最大问题就是，web 应用无法完整利用 CPU 资源，也就无法满足重计算的使用场景，使得在一段很长的一段时间里， web 只能开发蝇量级甚至草量级应用。</p><blockquote><p>蝇量级和草量级是职业拳击比赛中最轻的级别。</p></blockquote><h2 id="worker-和-多线程" tabindex="-1">Worker 和 多线程 <a class="header-anchor" href="#worker-和-多线程" aria-label="Permalink to &quot;Worker 和 多线程&quot;">​</a></h2><p>为了解决这个问题， WebWorker 应运而生，作为 HTML5 标准的一部分加入到浏览器内核中。</p><ul><li><p>Worker 线程由主线程或者另一个 Worker 线程创建，独立运行，创建 Worker 的宿主可以在任何时候杀死被创建的 Worker；</p></li><li><p>主线程和 Worker 线程拥有完全独立的上下文，数据隔离，不能互相访问变量，数据通信需要调用专门的接口实现；</p></li><li><p>Worker 线程上下文和主线程几乎一致，但 Worker 不能访问 DOM 接口。</p></li></ul><p>尽管浏览器具有多线程特性，但数据隔离、 Worker 不可操作 DOM 等特性，依然保证了 JavaScript 单线程的本质。这样一来，主线程就可以专心地处理用户交互，计算密集型和高延迟的任务就交给 Worker 线程，保持 UI 流畅，用户体验满分。</p><h2 id="web-workers-api" tabindex="-1">Web Workers API <a class="header-anchor" href="#web-workers-api" aria-label="Permalink to &quot;Web Workers API&quot;">​</a></h2><p>Web Worker 通过宿主提供的 Web Workers API 来实现，非常灵活的是，Web Worker 也支持 Web Workers API ，意味着我们可以嵌套创建 Worker 。</p><p>通过实例化一个 Worker 对象，创建一个新的 worker 线程，Worker 挂载在 <code>window</code> 对象（ Worker 内部是 <code>slef</code> 对象）中，使用前，应该检查一下当前浏览器是否支持 Worker：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Worker) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;当前浏览器不支持 Worker &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // your code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Worker 是一个构造函数，接受两个参数：</p><ul><li><p>aURL ， <code>USVString</code> 类型参数，用于指定脚本文件路径。注意，这个脚本必须是同源脚本</p></li><li><p>options ，配置参数</p></li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;worker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>主线程与子线程之间通过事件进行数据通信，且数据传输是双向的。发送端调用 <code>postMessage()</code> 函数向接收端发送数据，接收端通过注册 <code>onmessage</code> 事件来接收数据，类似 iframe 通信。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 主线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message, [transfer]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">evt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 数据通过 data 属性访问</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> evt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // other code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>数据传输都是<strong>深拷贝</strong>，即深拷贝调用方数据发送给接收方，但 Worker 专用的 <code>postMessage()</code> 比 iframe 的更加“高级”，除了待发送数据，它还支持 transfer 数组参数。</p><blockquote><p>transfer 数据接受 <code>Transferable</code> 对象，包含： <code>ArrayBuffer</code> 、 <code>MessagePort</code> 、 <code>ImageBitmap</code> 和 <code>OffscreenCanvas</code> 。</p></blockquote><p><code>Transferable</code> 是一种特殊的数据类型，区别于常规的 JavaScript 数据，<code>Transferable</code> 类型存储的是二进制数据。当宿主指定一组 transfer 数据时，实际上是将指定的二进制数据句柄传送给了子线程，并不发生数据复制，且在传送之后，子线程接管句柄所指向的数据块，同时断绝了宿主对这块数据的访问权限。这类似于 C 语言中指针的传递，相比于指针，transfer 只允许单独一个线程访问，避免了竞争。</p><p>当子线程运行结束，不再使用时，应当关闭子进程，节省系统资源：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 主线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">terminate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="多线程编程实践" tabindex="-1">多线程编程实践 <a class="header-anchor" href="#多线程编程实践" aria-label="Permalink to &quot;多线程编程实践&quot;">​</a></h2><h3 id="最佳线程数" tabindex="-1">最佳线程数 <a class="header-anchor" href="#最佳线程数" aria-label="Permalink to &quot;最佳线程数&quot;">​</a></h3><p>一般地，在操作系统空闲的时候，我们利用 CPU 所有线程参与运算是最快的。BOM 上有一个只读参数 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/hardwareConcurrency" target="_blank" rel="noreferrer"><code>window.navigator.hardwareConcurrency</code></a> 专门用于查询当前计算机可用的逻辑处理器数量，在开启多线程之前，查询这个参数确定最大的线程数。</p><p>程序的运行过程中，我们无法实时监控 CPU 的空闲线程数量，也就很难做到线程数动态分配。作者的经验是，无论什么时候，都开启最大线程数，至于 CPU 实际能用几个线程，如何分配线程，我们把这个任务交给浏览器来处理。</p><h3 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to &quot;线程池&quot;">​</a></h3><p>当某个耗时很长的模块需要反复调用时，可以对这个模块创建一个 Worker 线程池，线程池中的每一个元素对应一个 Worker 线程和线程当前使用状态:</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> workerList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查询 CPU 线程数量，创建线程池</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.navigator.hardwareConcurrency; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newWorker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    worker: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cpuworker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    inUse: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  workerList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newWorker);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>inUse</code> 为 <code>false</code> 时，表示线程闲；找到某个闲 Worker ，执行 <code>postMessage()</code> 函数，同时将 <code>inUse</code> 赋值为 <code>true</code> ，标记为线程忙，其他任务就不能再执行这个 Worker 了；Worker 执行完毕，返回数据到主线程，主线程释放线程池中对应的 Worker ，将 <code>inUse</code> 重新置为 <code>false</code> 。如果线程池里面的线程全部都为忙状态，那么就需要进入等待，直到有空闲的线程出现为止。</p><h3 id="worker-嵌套" tabindex="-1">Worker 嵌套 <a class="header-anchor" href="#worker-嵌套" aria-label="Permalink to &quot;Worker 嵌套&quot;">​</a></h3><p>当出现庞大的数量处理场景时，我们可以把大量的数据拆分成规模较小的若干分，分别送入 Worker 中执行计算，最后再将数据拼接起来获得结果。如果在主线程中拆分和拼接超长数组，也可能会造成 UI 阻塞；如果只是将计算放入一个线程，把耗时操作从一个线程转移到另一个线程，性能并不能提高。所以这里应该采取多线程嵌套策略：主线程开启一个主 Worker 专门用于数据拆分和拼接，在拆分过程中，动态创建子 Worker 执行运算，最后在主 Worker 中汇总拼接数据，返回最终结果到主线程。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 主线程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mainWorker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, [data.buffer]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获得处理后的数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 关闭主 Worker ，回收资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">terminate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// mainWorker.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 主 Worker 已经占用了一个线程了，这里需要减一</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cpuNum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> self.navigator.hardwareConcurrency </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slice </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpuNum;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 申请一块内存，用于存放结果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> iData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 记录一下忙线程的数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> workersInUse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpuNum;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpuNum; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> start</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slice;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slice;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 平均切分数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(start, end);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> subWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;subWorker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    subWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sData, [sData.buffer]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    subWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 数组拼接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      iData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, start);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      workersInUse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 关闭子 Worker ，回收资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      subWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">terminate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (workersInUse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iData, [iData.buffer]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// subWorker.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里执行耗时的运算</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> iData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFuntion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iData, [iData.buffer]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><blockquote><p>Worker 数量可以超过 CPU 可用线程数量吗？实操上是可以的，浏览器会协调实际线程的调用，但子线程数量超过硬件可以负担的最大数量时，性能并不能提升，而且反倒可能降低。</p></blockquote><h2 id="多线程性能对比" tabindex="-1">多线程性能对比 <a class="header-anchor" href="#多线程性能对比" aria-label="Permalink to &quot;多线程性能对比&quot;">​</a></h2><p>这里提供一个 Worker 嵌套方案的例子作为 benchmark ，线程调度方案如下：</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rdkxgedp0smlwjtrt5qg.png" alt="线程调度"></p><p>测试程序将对一张分辨率为 7451*4192 位图进行像素遍历，找出颜色值不为 #000000 的像素点，并绘制为其他颜色，同时对 #000000 像素点添加噪声。对比一下在单线程、双线程和多线程之间的性能，直接看数据：</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wklldiqijzinn48g4m7o.png" alt="benchmark"></p><p>可以看到</p><ol><li><p>主线程解析，页面失去响应，持续超过 1.3 秒</p></li><li><p>单开一个 Worker 线程解析，需要耗时约 1.3 秒，解析能力没有明显提升，但页面不会失去响应</p></li><li><p>多开 Worker 线程解析，仅需 240 毫秒，性能提升非常明显（测试设备逻辑核心数为 16）, 性能提升了近 82%</p></li></ol><h2 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h2><p>Worker 的使用很简单，但是有时候会有一些限制</p><h3 id="脚本同源限制" tabindex="-1">脚本同源限制 <a class="header-anchor" href="#脚本同源限制" aria-label="Permalink to &quot;脚本同源限制&quot;">​</a></h3><p>Worker 脚本必须同源，且不支持 <code>file://</code> 协议，所以必须启动一个服务器容器来调试 Worker 程序。我们经常会将脚本当做资源部署到 CDN 中，应用入口和 CDN 不在同一个域中时，跨域会导致 Worker 代码加载失败。</p><p>注意到，构造函数 Worker 的第一个参数 <code>aURL</code> 类型是 <code>USVString</code> 而非 <code>String</code> ，<code>USVString</code> 支持 <code>DOMString</code> 和 <code>String</code> 两种类型，也就是说，<code>aURL</code> 不一定非得是脚本文件服务端地址，也可以是本地资源描述符。</p><p>将获取到的 Worker 代码转换成 Blob 对象，使用 <code>URL.createObjectURL()</code> 创建出 <code>DOMString</code> ，就可以作为代码的源传入 Worker 构造函数中，例如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`console.log(&#39;hello world!&#39;);\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> workerBlob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Blob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([script], { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createObjectURL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(workerBlob);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>还有一种做法，就是将 JavaScript 字符串代码编译成 base64 字符串，这个方法比较简单不再赘述。</p><blockquote><p>相比起来，将脚本代码转换成 Blob 的方法比 base64 高效，推荐使用 Blob。</p></blockquote><h3 id="工程化问题" tabindex="-1">工程化问题 <a class="header-anchor" href="#工程化问题" aria-label="Permalink to &quot;工程化问题&quot;">​</a></h3><p>现代前端项目普遍采用如 webpack 、 vite 等高级工程化工具管理，可以参考 <a href="https://webpack.js.org/guides/web-workers" target="_blank" rel="noreferrer">webpack worker-loader</a> 和 <a href="https://vite.dev/guide/features.html#web-workers" target="_blank" rel="noreferrer">vite web-workers</a> 相关章节了解工程化的做法。</p><h3 id="api-访问限制" tabindex="-1">api 访问限制 <a class="header-anchor" href="#api-访问限制" aria-label="Permalink to &quot;api 访问限制&quot;">​</a></h3><p>Worker 具有一套和宿主相似的全局变量，可以通过访问 self 对象获取全局资源。但是 Worker 无法访问 DOM ，无法使用 <code>alert()</code> <code>confirm()</code> 等函数，可以使用 <code>console</code> <code>debugger</code> 等函数进行代码调试。详细的全局变量说明可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API#worker_global_contexts_and_functions" target="_blank" rel="noreferrer">这里</a>。</p>`,62)]))}const c=i(l,[["render",p]]);export{o as __pageData,c as default};
