import{_ as e,c as s,o as l,a8 as t}from"./chunks/framework.Cc4yYURl.js";const h=JSON.parse('{"title":"WebAssembly 基础（一）","description":"","frontmatter":{"createDate":"2024/06/21"},"headers":[],"relativePath":"技术的小记/WebAssembly 基础（一）/index.md","filePath":"技术的小记/WebAssembly 基础（一）/index.md","lastUpdated":1755795391000}'),o={name:"技术的小记/WebAssembly 基础（一）/index.md"};function i(r,a,n,p,m,d){return l(),s("div",null,a[0]||(a[0]=[t('<h1 id="webassembly-基础-一" tabindex="-1">WebAssembly 基础（一） <a class="header-anchor" href="#webassembly-基础-一" aria-label="Permalink to &quot;WebAssembly 基础（一）&quot;">​</a></h1><p><strong>2024/06/21</strong></p><blockquote><p>本系列是读书笔记，比较零散</p></blockquote><nav class="table-of-contents"><ul><li><a href="#高级计算机语言的两种运行方式">高级计算机语言的两种运行方式</a></li><li><a href="#现代编译器结构">现代编译器结构</a><ul><li><a href="#webassembly-的编译流转过程">WebAssembly 的编译流转过程</a></li></ul></li><li><a href="#格式">格式</a></li><li><a href="#wasm-结构">wasm 结构</a></li></ul></nav><h2 id="高级计算机语言的两种运行方式" tabindex="-1">高级计算机语言的两种运行方式 <a class="header-anchor" href="#高级计算机语言的两种运行方式" aria-label="Permalink to &quot;高级计算机语言的两种运行方式&quot;">​</a></h2><ol><li>预先编译 Ahead-of-Time Compilation ，简称 AOT</li><li>即时编译 Just-in-Time Compilation ，简称 JIT</li></ol><p>像 C/C++ 这类属于预先编译的计算机语言，而 JavaScript 这种属于即时编译语言。</p><h2 id="现代编译器结构" tabindex="-1">现代编译器结构 <a class="header-anchor" href="#现代编译器结构" aria-label="Permalink to &quot;现代编译器结构&quot;">​</a></h2><p>编译器的最终目的是将高级计算机语言编译成机器语言，由于用户使用的 CPU 五花八门，相同的高级语言代码编译出来的可执行文件都有可能是不同的。为了提高效率，编译器会按照编译流程模块化设计。一般由 <strong>前端(Front End)</strong> 、<strong>中端(Middle End)</strong> 和 <strong>后端(Back End)</strong> 组成，每个节点都会产生中间表示(IR)传递给下一级。前端和中端的处理与硬件无关，最终在后端生成符合硬件参数的汇编代码。这种设计的好处在于，同一个编译器在不同的平台只需要开发不同的后端即可：</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xlaxeetcoumt3u9q4ozj.png" alt="编译器结构"></p><p>举个例子，C 的编译过程：</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jbu6gh39qw1d2c4pn6jr.png" alt="C 语言编译"></p><h3 id="webassembly-的编译流转过程" tabindex="-1">WebAssembly 的编译流转过程 <a class="header-anchor" href="#webassembly-的编译流转过程" aria-label="Permalink to &quot;WebAssembly 的编译流转过程&quot;">​</a></h3><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ngg9d01lyehgosmy6qhw.png" alt="WebAssembly 的编译流转过程"></p><p>WASM 是编译器的目标代码，但从浏览器的角度来看，WASM 更像是中端产出的 IR 。最终要被 AOT/JIT 编译器编译成平台相关的机器码。</p><h2 id="格式" tabindex="-1">格式 <a class="header-anchor" href="#格式" aria-label="Permalink to &quot;格式&quot;">​</a></h2><ol><li>二进制格式，文件后缀是 .wasm</li><li>文本格式，文件后缀是 .wat</li><li>内存格式</li></ol><p>二进制格式是 wasm 模块的主要格式，文本格式是为了方便开发者调试和理解 wasm 。但其实 wat 的阅读性也很差，如同读汇编。</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mr1oiwhrpxablv76ef9a.png" alt="3种格式"></p><p>wasm 模块必须安全可靠，所以在进入实例化之前，浏览器会先解码 wasm 为内存格式(in-memory) ，使用内存格式进行验证。</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xpwujfp0tiudyyhmhvqe.png" alt="语义阶段"></p><h2 id="wasm-结构" tabindex="-1">wasm 结构 <a class="header-anchor" href="#wasm-结构" aria-label="Permalink to &quot;wasm 结构&quot;">​</a></h2><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/uxdarln3ak447aivnv2k.png" alt="wasm 结构"></p><p>流式(Streamable)加载 + 严格的段顺序，保证 wasm 可以一遍(One-Pass)完成代码的加载、解析、验证和编译。</p>',24)]))}const b=e(o,[["render",i]]);export{h as __pageData,b as default};
