import{_ as a,c as i,o as t,a8 as e}from"./chunks/framework.Cc4yYURl.js";const k=JSON.parse('{"title":"JavaScript 变量类型判断","description":"","frontmatter":{"createDate":"2025/07/12","title":"JavaScript 变量类型判断"},"headers":[],"relativePath":"技术的小记/JavaScript 变量类型判断/index.md","filePath":"技术的小记/JavaScript 变量类型判断/index.md","lastUpdated":1756188621000}'),n={name:"技术的小记/JavaScript 变量类型判断/index.md"};function l(p,s,r,d,o,c){return t(),i("div",null,s[0]||(s[0]=[e(`<h1 id="javascript-变量类型判断" tabindex="-1">JavaScript 变量类型判断 <a class="header-anchor" href="#javascript-变量类型判断" aria-label="Permalink to &quot;JavaScript 变量类型判断&quot;">​</a></h1><p><strong>2025/07/12</strong></p><nav class="table-of-contents"><ul><li><a href="#javascript-数据类型">JavaScript 数据类型</a></li><li><a href="#类型检查方案">类型检查方案</a><ul><li><a href="#typeof">typeof</a></li><li><a href="#instanceof">instanceof</a></li><li><a href="#constructor">constructor</a></li><li><a href="#object-prototype-tostring-call">Object.prototype.toString.call()</a></li></ul></li><li><a href="#总结">总结</a></li></ul></nav><h2 id="javascript-数据类型" tabindex="-1">JavaScript 数据类型 <a class="header-anchor" href="#javascript-数据类型" aria-label="Permalink to &quot;JavaScript 数据类型&quot;">​</a></h2><p>JavaScript 是一种变量类型不敏感的语言，在使用变量的过程中，难免需要对其类型进行判断。但是 JavaScript 没有严格定义基本类型，自顶向下看，只有 <strong><code>Primitive</code></strong>（原始值，或者叫原始数据类型） 和 <strong><code>object</code></strong> 两种类型。区分 原始值 和 object 的方法很简单，原始值不具有属性和方法，但 object 有。原始值<strong>不可修改</strong>，是 JavaScript 最底层的数据类型表示，开发者在日常开发中，很难直接接触到原始值，每次需要访问原始值时， JavaScript 会自动地构造一个对象将原始值封装起来。举个例子，字符串 <code>&#39;foo&#39;</code> 是原始值，当运行代码 <code>&#39;foo&#39;.includes(&#39;f&#39;)</code> 时，创建 <code>String</code> 自动地将 <code>&#39;foo&#39;</code> “包裹”起来，<code>&#39;foo&#39;</code> 本身不具有任何方法和属性，实际上是在访问 <code>String.prototype.includes()</code> 。</p><blockquote><p>原始值 （Primitive）有 7 种：</p></blockquote><ul><li>string</li><li>number</li><li>bigint</li><li>boolean</li><li>undefined</li><li>symbol</li><li>null</li></ul><p>除了 <code>undefined</code> 和 <code>null</code> 外，不同的原始值会被封装成不同的对象，为访问原始值提供丰富且实用的途径。所以直接尝试访问 <code>null</code> 和 <code>undefined</code> 的属性方法会发生错误，这也就验证了原始值并不具备属性和方法的特性。</p><table tabindex="0"><thead><tr><th>Type</th><th>Object wrapper</th></tr></thead><tbody><tr><td>Null</td><td>N/A</td></tr><tr><td>Undefined</td><td>N/A</td></tr><tr><td>Boolean</td><td>Boolean</td></tr><tr><td>Number</td><td>Number</td></tr><tr><td>BigInt</td><td>BigInt</td></tr><tr><td>String</td><td>String</td></tr><tr><td>Symbol</td><td>Symbol</td></tr></tbody></table><p>除了原始值本身，原始值还可以组成各种集合，比如说数组、日期。JavaScript 同样是提供丰富的内置对象来表示这些类型（<code>Array</code>、 <code>Date</code> 等）。这些对象的原型，无一例外都是 <code>Object</code> 的原型，甚至用于表示函数的 <code>Function</code> ，其原型也是 <code>Object</code> 的原型。</p><p>所以，对 JavaScript 变量类型的检查，归根结底就是<strong>对变量原始值和原型的检查</strong>。</p><h2 id="类型检查方案" tabindex="-1">类型检查方案 <a class="header-anchor" href="#类型检查方案" aria-label="Permalink to &quot;类型检查方案&quot;">​</a></h2><h3 id="typeof" tabindex="-1"><code>typeof</code> <a class="header-anchor" href="#typeof" aria-label="Permalink to &quot;\`typeof\`&quot;">​</a></h3><p><code>typeof</code> 返回被检查变量操作数值的类型。</p><p>用法</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typeof operand</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &quot;boolean&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><table tabindex="0"><thead><tr><th>Type</th><th>Result</th></tr></thead><tbody><tr><td>Undefined</td><td>&quot;undefined&quot;</td></tr><tr><td>Null</td><td>&quot;object&quot;</td></tr><tr><td>Boolean</td><td>&quot;boolean&quot;</td></tr><tr><td>Number</td><td>&quot;number&quot;</td></tr><tr><td>BigInt</td><td>&quot;bigint&quot;</td></tr><tr><td>String</td><td>&quot;string&quot;</td></tr><tr><td>Symbol</td><td>&quot;symbol&quot;</td></tr><tr><td>Function</td><td>&quot;function&quot;</td></tr><tr><td>Any other object</td><td>&quot;object&quot;</td></tr></tbody></table><p>这是用于检查变量原始值最直接的方式。由于历史原因， <code>null</code> 会被判别为 <code>object</code> ，这是一个 bug 。一开始 JavaScript 值的存储被设计成 类型 tag + 值 的结构，object 的类型 tag 被设计成 <code>000</code> ，null 表示空指针，被指向内存 <code>0x00</code> 的位置， 最终 null 和 object 的类型标签都是 <code>000</code> ，typeof 实现中，000 标签只检查了值是否可执行（可执行的对象是 function ，不可执行就是 object ），导致 <code>typeof null</code> 的结果是 <code>&#39;object&#39;</code> 。</p><blockquote><p>关于 <code>null</code> 被识别成 <code>object</code> 的历史原因，可以参考<a href="https://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noreferrer">这篇文章</a>。</p></blockquote><p><code>typeof</code> 的优势是简单，劣势是无法检查除 function 外的其他内置对象，更不能检查开发者自己创建的对象，检查 null 时需要编写额外的代码。</p><h3 id="instanceof" tabindex="-1"><code>instanceof</code> <a class="header-anchor" href="#instanceof" aria-label="Permalink to &quot;\`instanceof\`&quot;">​</a></h3><p><code>instanceof</code> 用来检查实例的构造函数原型是否在给定构造函数的原型链上。</p><p>用法</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>object instanceof constructor</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同样输出 true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上文提到过，所有对象都是从 <code>Object</code> 的原型继承而来的，所以任何实例原型链上应该都会存在 <code>Object</code> 的原型。具体来说，当执行 <code>object instanceof constructor</code> 时，执行器会去找对象实例中是否有 <code>Symbol.hasInstance</code> 函数，如果有，执行这个函数并返回 <code>Boolean</code> 结果；如果没有，则从构造函数开始往原型链顶端寻找，直到最开始的 object 为止。</p><p>使用 <code>Symbol.hasInstance</code> 可以修改原型链，这也就意味着 instanceof 的结果可能“不准确”，例如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FakeArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Symbol.hasInstance](</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">instance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FakeArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>instanceof</code> 用来检查实例的类型很方便好用，可能会遍历整个原型链，但是无法用来检查 <code>null</code> 和 <code>undefined</code> ，也可能由于修改了 <code>Symbol.hasInstance</code> 导致检查结果不准确。</p><h3 id="constructor" tabindex="-1"><code>constructor</code> <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;\`constructor\`&quot;">​</a></h3><p>实例的 <code>constructor</code> 属性指向创建这个实例的构造函数。</p><p>用法：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>obj.constructor</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>任何对象实例都具有构造函数（除非特意构造一个原型指向 null 的对象），利用这个属性可以轻松地获取到实例的构造函数类型，且可以避免整个原型链的遍历。</p><h3 id="object-prototype-tostring-call" tabindex="-1"><code>Object.prototype.toString.call()</code> <a class="header-anchor" href="#object-prototype-tostring-call" aria-label="Permalink to &quot;\`Object.prototype.toString.call()\`&quot;">​</a></h3><p>对象的 <code>toString</code> 方法返回当前对象的字符串表达。</p><p><code>Object</code> 实例的字符串表达是 <code>&#39;[object Object]&#39;</code> 。<code>toString</code> 是可以修改的，在不同的对象实现中，返回的字符串表达不尽相同，比如字符串对象返回的是原始值，数组对象返回的是 <code>Array.protype.join(&#39;,&#39;)</code> 。只有原型链顶端，原汁原味的 <code>Object.prototype.toString</code> 返回对象类型 <code>&#39;[object Type]&#39;</code> 。利用这个特性，可以通过 <code>Object.prototype.toString.call(obj)</code> 获取到对象的类型。和 instanceof 一样，<code>toString</code> 也可能不准确，因为类型描述同样可以修改：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FakeArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Symbol.toStringTag]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Array&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FakeArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;[object Array]&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><table tabindex="0"><thead><tr><th>方法</th><th>优势</th><th>劣势</th><th>场景</th></tr></thead><tbody><tr><td>typeof</td><td>通俗易懂，原始值检查最方便</td><td>无法检查 null ，也无法检查各种对象</td><td>接口数据通常是原始值，非常适合这个场景的类型检查</td></tr><tr><td>instanceof</td><td>遍历整个原型链，任何一个类型都不放过</td><td>null 、 undefined 和原始值无法检查，可以被修改结果不准确</td><td>对象类型检查普遍适用</td></tr><tr><td>constructor</td><td>构造函数不会被修改，准确</td><td>构造函数为 null 的对象会出错，需要引入构造函数做对比，如果构造函数立即执行且不具名，使用起来比较麻烦</td><td>对象类型检查普遍适用</td></tr><tr><td>toString</td><td>返回结果是描述，使用方便</td><td>代码冗长，可能被修改结果</td><td>对象类型检查普遍适用</td></tr></tbody></table><p>没有一种方案是“银弹”，需要组合其中几种方案来识别任意变量的类型。mozilla 提供了一种非常详尽的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#custom_method_that_gets_a_more_specific_type" target="_blank" rel="noreferrer">示例</a>，可以作为变量判断的参考。</p>`,42)]))}const b=a(n,[["render",l]]);export{k as __pageData,b as default};
