import{_ as i,c as a,o as e,a9 as n}from"./chunks/framework.GQWhFI7o.js";const c=JSON.parse('{"title":"EMSCRIPTEN 多线程编程笔记","description":"","frontmatter":{"createDate":"2025/09/19","tags":"WebAssembly, EMSCRIPTEN, pthread"},"headers":[],"relativePath":"技术的小记/EMSCRIPTEN 多线程编程笔记/index.md","filePath":"技术的小记/EMSCRIPTEN 多线程编程笔记/index.md","lastUpdated":1758275246000}'),l={name:"技术的小记/EMSCRIPTEN 多线程编程笔记/index.md"};function r(t,s,p,h,d,k){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="emscripten-多线程编程笔记" tabindex="-1">EMSCRIPTEN 多线程编程笔记 <a class="header-anchor" href="#emscripten-多线程编程笔记" aria-label="Permalink to &quot;EMSCRIPTEN 多线程编程笔记&quot;">​</a></h1><p>2025年09月19日</p><nav class="table-of-contents"><ul><li><a href="#操作系统的多线程">操作系统的多线程</a></li><li><a href="#emscripten-的多线程">EMSCRIPTEN 的多线程</a><ul><li><a href="#sharedarraybuffer">SharedArrayBuffer</a></li><li><a href="#cross-origin-isolated">cross-origin isolated</a></li><li><a href="#主线程阻塞">主线程阻塞</a></li></ul></li></ul></nav><h2 id="操作系统的多线程" tabindex="-1">操作系统的多线程 <a class="header-anchor" href="#操作系统的多线程" aria-label="Permalink to &quot;操作系统的多线程&quot;">​</a></h2><p>进程是操作系统分配资源的最小单位，每创建一个新的进程，会把父进程的资源复制一份到子进程。而线程是一种轻量级的进程，不独立拥有系统资源，操作系统内核是按照线程作为调度单位来调度资源。每一个进程是由一个或者多个线程组成的。</p><p>进程中 Text、Data、BSS 和 Heap 部分线程之间共享，Stack 不共享，每个线程拥有自己独立的栈。</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hwcag6umsqdenarcv31f.png" alt="进程和线程的内存资源" loading="lazy"></p><p>Linux 系统中普遍使用 pthread 库开发多线程程序，pthread 符合 POSIX 标准，提供管理和操作线程的方法，包含在 <code>pthread.h</code> 头文件中。同一个进程中，除了栈，所有线程共享同一份内存，同时因为线程的执行是并行的，所以不可避免地发生资源竞争的问题，即同一时间有多个线程试图获取或者修改同一个内存资源。当开发者小心翼翼地处理内存使用时，并行地读写内存可以带来效率提升，一旦不注意可能带来严重的问题。假设用 2 个线程执行如下代码，<code>counter</code> 的结果可能远小于 2000 ：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>pthread 提供了锁来解决这个问题，最常见的锁是互斥锁和读写锁。</p><ol><li>互斥锁：同一时间只能有唯一一个线程访问，使用 <code>pthread_mutex_t</code></li><li>读写锁：同一时间只能有唯一一个线程写入，允许多个线程读取， 使用 <code>pthread_rwlock_t</code></li></ol><blockquote><p>这里不打算展开 Linux 多线程编程，超出了本篇讨论的重点。</p></blockquote><h2 id="emscripten-的多线程" tabindex="-1">EMSCRIPTEN 的多线程 <a class="header-anchor" href="#emscripten-的多线程" aria-label="Permalink to &quot;EMSCRIPTEN 的多线程&quot;">​</a></h2><p>浏览器是一个多线程应用，我们在《<a href="https://dev.to/yangholmes/web-ying-yong-zha-gan-cpu-xing-neng-de-zheng-que-zi-shi-218n" target="_blank" rel="noreferrer">web 应用榨干 CPU  性能的正确姿势</a>》一文中介绍过这些线程，这里引用一张图：</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3psq8x3j384qxosrchx9.png" alt="浏览器线程" loading="lazy"></p><p>这些线程由浏览器管理，开发者并不能干预，可以把这些线程看作是“不可编程”的多线程；浏览器向开发者提供了“可编程”的多线程，那就是 <code>Worker</code> 。《<a href="https://dev.to/yangholmes/web-ying-yong-zha-gan-cpu-xing-neng-de-zheng-que-zi-shi-218n" target="_blank" rel="noreferrer">web 应用榨干 CPU  性能的正确姿势</a>》介绍了在 JavaScript 中如何使用 <code>Worker</code> 实现多线程编程，并介绍了线程之间 Transferable objects 数据传输方式。 Transferable objects 有点类似 互斥锁 ，数据从一个线程传输至另一个线程的时候，不进行数据拷贝，而是传递数据所在的内存<strong>所有权</strong>，数据传输完成之后，只有接收线程可以访问这块数据，其他线程都无法访问；和互斥锁不同的是， Transferable objects 没有“解锁”方法，如果需要将数据“还给”发送线程，就按照 Transferable objects 的方式重新发送数据。Transferable objects 数据适用于 <code>ArrayBuffer</code> 一类数据，没有“共享”的属性。如果想要在不同的线程之间“共享”内存，就像使用真正的内存那样，就需要使用 <code>SharedArrayBuffer</code> 。</p><p><code>Worker</code> 和 <code>SharedArrayBuffer</code> 正是 emscripten 多线程的实现基础，尽可能地实现 POSIX 标准的 pthread 功能。<code>Worker</code> 实现了独立栈和共享 Text， <code>SharedArrayBuffer</code> 实现了共享堆，和文件系统类似，也是通过替换系统函数，移花接木。</p><h3 id="sharedarraybuffer" tabindex="-1">SharedArrayBuffer <a class="header-anchor" href="#sharedarraybuffer" aria-label="Permalink to &quot;SharedArrayBuffer&quot;">​</a></h3><p><code>SharedArrayBuffer</code> 对象表示一块二进制内存缓冲区，和 <code>ArrayBuffer</code> 类似，但 <code>SharedArrayBuffer</code> 可以被共享同时不能被 transfer 。<code>new SharedArrayBuffer(length)</code> 效果和 <code>calloc(nmemb, size)</code> 非常类似，运行之后都可以获得值<strong>全为 0</strong> 的内存，只不过 <code>SharedArrayBuffer</code> 长度为 <code>length * 8 bit</code> ， <code>calloc</code> 长度为 <code>nmemb * size bit</code> 。也就是说，<code>SharedArrayBuffer</code> 申请的内存是没有类型的，使用的时候需要根据实际情况构造成相应的 <code>TypedArray</code> 类型。</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sab);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ta[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ta[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ta[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sab);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>SharedArrayBuffer</code> 可以在主线程和多个 <code>Worker</code> 线程中创建、传输和修改，当多个线程同时使用同一块内存时，这块内存的修改传播到不同上下文需要花费一些时间，也就是说，修改生效不是立即的，和操作系统上多线程内存操作一样。使用上 1 节的例子，当 2 个线程执行如下代码后，<code>counter</code> 的结果可能远小于 2000 ：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在某一个线程创建共享内存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cosnt _counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShareArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_counter);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 2 个线程中执行累加</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (int i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) counter[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>JavaScript 并不采用“锁”来控制内存读写，而是提供 <code>Atomics</code> 对象来保证数据读写准确。<code>Atomics</code> 的细节请参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" target="_blank" rel="noreferrer">文档</a>，这里不赘述。如果想要让 <code>counter</code> 的最终结果是 2000 ，只需要简单修改一下加法命令：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Atomics.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(counter, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原子加操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>Atomics</code> 可以用来实现锁功能， emscripten 就是这么做的。简单地讲，使用 <code>Atomics.wait</code> 实现等待， <code>Atomics.compareExchange</code> 实现加锁，<code>Atomics.store</code> 实现解锁，<code>Atomics.notify</code> 实现通知线程。</p><h3 id="cross-origin-isolated" tabindex="-1">cross-origin isolated <a class="header-anchor" href="#cross-origin-isolated" aria-label="Permalink to &quot;cross-origin isolated&quot;">​</a></h3><p>使用 <code>SharedArrayBuffer</code> 必须满足两个条件：</p><ol><li>安全上下文，即 <code>https://</code>、 <code>wss://</code> 和 <code>localhost</code></li><li>cross-origin isolated ，即跨源隔离</li></ol><p>安全上下文想必大家都知道是什么含义，这里简单解析一下 cross-origin isolated（跨源隔离）。跨源隔离是一种网页的状态，此时只能在同源 <code>document</code> 共享上下文和使用 CORS 加载的资源（<code>&lt;iframe&gt;</code> 的话是 COEP ）。同时，浏览器将把这个源的页面<strong>独立一个进程</strong>来管理，意味着这个源的页面拥有独立的操作系统资源，崩溃报错不会轻易影响到其他页面。<code>SharedArrayBuffer</code> 必须在 cross-origin isolated 状态下使用，否则会找不到这个构造函数。除了 <code>SharedArrayBuffer</code> 外，cross-origin isolated 还具有其余两个特性：</p><ol><li><code>Performance.now()</code> 精度提高，提高到 5ms 甚至更高</li><li><code>Performance.measureUserAgentSpecificMemory()</code> 可用</li></ol><p>如何开启 cross-origin isolated ？在页面的响应头中添加 COEP 和 COOP ：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cross-Origin-Embedder-Policy: require-corp</span></span>
<span class="line"><span>Cross-Origin-Opener-Policy: same-origin</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>cross-origin isolated 会带来一些不便：</p><ol><li><p>非同源嵌入式资源无法直接加载，如 <code>&lt;img&gt;</code>、 <code>&lt;script&gt;</code>、 <code>&lt;video&gt;</code> 等，解决方法：</p><ol><li>在服务端设置正确的 <code>Access-Control-Allow-Origin</code> 响应头，并在标签中添加 <code>crossorigin</code>属性，如 <code>&lt;img src=&quot;***&quot; crossorigin&gt;</code></li><li>使用 <code>CORP</code> ，服务端为资源设置 <code>Cross-Origin-Resource-Policy</code> 响应头</li><li>代理转发，把跨域资源处理成为同源资源</li></ol></li><li><p><code>&lt;iframe&gt;</code> 必须显性标明跨域嵌入，否则无法加载</p></li><li><p>非同源 popup <code>window.opener</code> 为 <code>null</code></p></li><li><p>无法改写 <code>document.domain</code></p></li></ol><blockquote><p>是否开启多线程需要结合页面使用的资源情况来决定。</p></blockquote><p>如果不确定一个页面是否符合 cross-origin isolated ，可以读取 <code>window.crossOriginIsolated</code> 嗅探，在 worker 中为 <code>self.crossOriginIsolated</code> 。通常来说，无法提前预判运行环境是否跨源隔离，分别准备一套单线程方案和一套多线程方案，通过嗅探决定使用哪一种。</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (window.crossOriginIsolated) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;worker-pthread.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;worker-single.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer, [buffer]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="主线程阻塞" tabindex="-1">主线程阻塞 <a class="header-anchor" href="#主线程阻塞" aria-label="Permalink to &quot;主线程阻塞&quot;">​</a></h3><p>WebAssembly 在主线程唤起执行通常会导致主线程阻塞，进而引发 UI 卡死。一般的做法是把 WebAssembly 放到一个独立的线程去执行，这个在前面的文档中多次提及。在 emscripten 中，由于线程由编译器管理，根据当前硬件状况自动合理分配，如果此时手动再增加一个线程，可能会导致线程分配不合理。解决这个问题有两个方案：</p><ol><li>手动指定可用线程数。 <code>-sPTHREAD_POOL_SIZE=&lt;expression&gt;</code> 参数用来指定可用线程数，接受一个数字或一个 JavaScript 表示式。一般地我们会选择不传这个参数或者传入 <code>navigator.hardwareConcurrency</code> 。当开发者想要手动维护启动线程时，可以为启动线程保留一个线程数，设置为 <code>-sPTHREAD_POOL_SIZE=&quot;navigator.hardwareConcurrency-1&quot;</code></li><li>使用 <code>-sPROXY_TO_PTHREAD</code> 参数。添加这个参数后，c 程序中的 <code>main()</code> 函数会被替换成一个新的线程，在这个线程中运行原本的 <code>main()</code> 函数。相当于是方法 1 的自动化版本。有时候我们开发的 WebAssembly 模块并没有 <code>main()</code> 函数，此时可以参考使用方法 1</li></ol><p>这里建议使用 <code>-sPTHREAD_POOL_SIZE=&lt;expression&gt;</code> 参数，无论是否手动分配启动线程。原因是当指定了 <code>-sPTHREAD_POOL_SIZE=&lt;expression&gt;</code> 后，程序将提前创建好 workers ，当代码执行到 <code>pthread_create</code> 可以直接使用 worker 而不是从实例化开始，可以提高效率，并获得跟原生 c 更接近的运行效果。</p><blockquote><p><code>-sPROXY_TO_PTHREAD</code> 和 <code>--proxy-to-worker</code> 很像，都是将 <code>main()</code> 函数代理到 worker 中，带不一样的地方在于，<code>--proxy-to-worker</code> 只是纯粹代理 <code>main()</code> ，并不支持 <code>pthread</code> 和 <code>SharedArrayBuffer</code> 。</p></blockquote>`,42)]))}const E=i(l,[["render",r]]);export{c as __pageData,E as default};
